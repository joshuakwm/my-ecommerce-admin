Please carefully validate the current code implementation with the provided design documents and requirements:
Core Validation Points
Database Schema Alignment:

Does the Prisma schema match the table definitions from database_tables_details.txt?
Are all fields correctly represented with appropriate types and constraints?
Project Structure:

Are the file paths and module placements consistent with the expected directory structure?
Are shared components properly modularized for reuse?
Functional Requirements:

Are all features of the admin panel (dashboard, products, customers) implemented correctly and aligned with expectations?
Are the API endpoints complete and functioning as required?
Styling and Theming:

Is Tailwind CSS configured as per the tailwind.config.ts example?
Are the defined colors and dark mode being utilized effectively?
Authentication and Security:

Is NextAuth.js configured to handle authentication, even if only partially implemented?
Scalability and Extendability:

Does the project structure allow for the addition of future features like order tracking or sales reporting?
Error Handling:

Are there adequate checks and fallback mechanisms for API errors and missing data?

Steps to Verify:
Revisit the Prisma schema and cross-check all models against the database structure.
Validate that the implemented API endpoints match the required functionalities and provide correct data structures.
Test individual UI components like modals, tables, and panels to ensure proper state management and interactivity.
Ensure that styling, dark mode, and responsive design are handled as expected.

Begin by analyzing the provided Prisma schema and ensuring it's a precise representation of the tables. Then, review the components and routes.

// my-ecommerce-admin project
my-ecommerce-admin/
├── prisma/
│   ├── migrations/             # Migration files generated by Prisma
│   └── schema.prisma           # Prisma schema
├── public/                     # Static assets (e.g., images, icons)
│   └── images/
├── src/
│   ├── components/             # Shared and reusable components
│   │   ├── Dashboard/          # Dashboard components
│   │   ├── Products/           # Product management components
│   │   ├── Customers/          # Customer management components
│   │   ├── Orders/             # Order management components
│   │   ├── SalesReports/       # Sales reporting components
│   │   ├── Blog/               # Blog management components
│   │   ├── UI/                 # Generic UI components (e.g., Button, Modal)
│   │   └── Layout/             # Layout components (e.g., Sidebar, AdminLayout)
│   ├── pages/                  # Next.js routing
│   │   ├── _app.tsx            # Custom App component
│   │   ├── dashboard.tsx       # Dashboard page
│   │   ├── products/           # Products routes
│   │   ├── customers/          # Customers routes
│   │   ├── orders/             # Orders routes
│   │   ├── reports/            # Sales reports routes
│   │   ├── blog/               # Blog-related routes
│   │   └── api/                # API routes (e.g., authentication)
│   │       └── auth/
│   │           └── [...nextauth].ts
│   ├── styles/                 # Tailwind CSS and global styles
│   │   └── globals.css
│   └── utils/                  # Utility functions (e.g., API calls)
│       └── api.ts
├── .env.local                  # Environment variables
├── next.config.js              # Next.js configuration
├── tailwind.config.ts          # Tailwind CSS configuration
├── tsconfig.json               # TypeScript configuration
└── package.json                # Dependencies and scripts

// Step 1: Prisma Schema
// prisma/schema.prisma
model Customer {
  customer_id        Int       @id @default(autoincrement())
  name              String
  email             String    @unique
  phone             String?
  address           Json?
  registration_date DateTime  @default(now())
  newsletter_opt_in Boolean   @default(false)
  subscription_status String  @default("unsubscribed")
  orders            Order[]
}

model Product {
  product_id     Int      @id @default(autoincrement())
  name           String
  category       String?
  price          Float
  stock_quantity Int      @default(0)
  description    String?
  created_at     DateTime @default(now())
  featured       Boolean  @default(false)
  image_url      String?
  orderItems     OrderItem[]
}

model Order {
  order_id     Int      @id @default(autoincrement())
  customer_id  Int?
  customer     Customer? @relation(fields: [customer_id], references: [customer_id])
  status       String
  total_amount Float
  created_at   DateTime @default(now())
  orderItems   OrderItem[]
}

model OrderItem {
  order_item_id Int      @id @default(autoincrement())
  order_id      Int
  product_id    Int
  quantity      Int
  price         Float
  order         Order   @relation(fields: [order_id], references: [order_id])
  product       Product @relation(fields: [product_id], references: [product_id])
}

model BlogPost {
  post_id      Int      @id @default(autoincrement())
  title        String
  content      String
  author_id    Int
  author       BlogAuthor @relation(fields: [author_id], references: [author_id])
  category_id  Int
  category     BlogCategory @relation(fields: [category_id], references: [category_id])
  published_at DateTime @default(now())
  comments     BlogComment[]
}

model BlogAuthor {
  author_id Int    @id @default(autoincrement())
  name      String
  email     String @unique
  bio       String?
  posts     BlogPost[]
}

model BlogCategory {
  category_id Int    @id @default(autoincrement())
  name        String @unique
  posts       BlogPost[]
}

model BlogComment {
  comment_id   Int      @id @default(autoincrement())
  post_id      Int
  post         BlogPost @relation(fields: [post_id], references: [post_id])
  author_name  String
  author_email String
  content      String
  commented_at DateTime @default(now())
}

// Step 2: Tailwind Config
// tailwind.config.ts
export const config = {
  content: ["./src/**/*.{js,ts,jsx,tsx}"],
  darkMode: "class",
  theme: {
    extend: {
      colors: {
        "primary": "#4CAF50",
        "secondary": "#FFC107",
      },
    },
  },
};

// Step 3: Global Styles
// src/styles/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;
body {
  @apply bg-gray-100 text-gray-900 dark:bg-gray-800 dark:text-white;
}

// Step 4: Dashboard Page
// src/pages/dashboard.tsx
import React from "react";
import useSWR from "swr";
import fetcher from "@/utils/api";
import AdminLayout from "@/components/Layout/AdminLayout";
import KeyMetricsCard from "@/components/Dashboard/KeyMetricsCard";
import RecentOrdersTable from "@/components/Dashboard/RecentOrdersTable";

const Dashboard: React.FC = () => {
  const { data: metrics, error: metricsError } = useSWR("/api/dashboard/metrics", fetcher);
  const { data: recentOrders, error: ordersError } = useSWR("/api/dashboard/recent-orders", fetcher);

  if (metricsError || ordersError) {
    return <div>Error loading data.</div>;
  }

  if (!metrics || !recentOrders) {
    return <div>Loading...</div>;
  }

  return (
    <AdminLayout>
      <h1 className="text-2xl font-bold mb-6">Dashboard</h1>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <KeyMetricsCard title="Total Sales" value={metrics.totalSales} prefix="$" />
        <KeyMetricsCard title="Total Customers" value={metrics.totalCustomers} />
        <KeyMetricsCard title="Total Orders" value={metrics.totalOrders} />
      </div>

      <div>
        <h2 className="text-xl font-semibold mb-4">Recent Orders</h2>
        <RecentOrdersTable orders={recentOrders} />
      </div>
    </AdminLayout>
  );
};

export default Dashboard;

// Step 5: API Routes
// src/pages/api/dashboard/metrics.ts
import { NextApiRequest, NextApiResponse } from "next";
import prisma from "@/lib/prisma";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const totalSales = await prisma.order.aggregate({
      _sum: { total_amount: true },
    });

    const totalCustomers = await prisma.customer.count();
    const totalOrders = await prisma.order.count();

    res.status(200).json({
      totalSales: totalSales._sum.total_amount || 0,
      totalCustomers,
      totalOrders,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Failed to load metrics" });
  }
}

// src/pages/api/dashboard/recent-orders.ts
import { NextApiRequest, NextApiResponse } from "next";
import prisma from "@/lib/prisma";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const recentOrders = await prisma.order.findMany({
      take: 5,
      orderBy: { created_at: "desc" },
      include: { customer: true },
    });

    res.status(200).json(recentOrders);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Failed to load recent orders" });
  }
}

// Step 6: Product Management Components
// src/components/Products/ProductsPanel.tsx
import React, { useState } from "react";
import useSWR from "swr";
import fetcher from "@/utils/api";
import ProductTable from "@/components/Products/ProductTable";
import AddEditProductModal from "@/components/Products/AddEditProductModal";

const ProductsPanel: React.FC = () => {
  const { data: products, error } = useSWR("/api/products", fetcher);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedProduct, setSelectedProduct] = useState(null);

  const handleAddProduct = () => {
    setSelectedProduct(null);
    setIsModalOpen(true);
  };

  const handleEditProduct = (product: any) => {
    setSelectedProduct(product);
    setIsModalOpen(true);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
  };

  if (error) return <div>Error loading products.</div>;
  if (!products) return <div>Loading...</div>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Products</h1>
        <button
          className="bg-primary text-white px-4 py-2 rounded"
          onClick={handleAddProduct}
        >
          Add Product
        </button>
      </div>
      <ProductTable products={products} onEdit={handleEditProduct} />
      <AddEditProductModal
        isOpen={isModalOpen}
        onClose={handleCloseModal}
        product={selectedProduct}
      />
    </div>
  );
};

export default ProductsPanel;

// src/components/Products/ProductTable.tsx
import React from "react";

const ProductTable = ({ products, onEdit }: { products: any[]; onEdit: (product: any) => void }) => {
  return (
    <table className="min-w-full bg-white">
      <thead>
        <tr>
          <th className="px-4 py-2">Name</th>
          <th className="px-4 py-2">Category</th>
          <th className="px-4 py-2">Price</th>
          <th className="px-4 py-2">Actions</th>
        </tr>
      </thead>
      <tbody>
        {products.map((product) => (
          <tr key={product.product_id}>
            <td className="border px-4 py-2">{product.name}</td>
            <td className="border px-4 py-2">{product.category}</td>
            <td className="border px-4 py-2">${product.price}</td>
            <td className="border px-4 py-2">
              <button
                className="text-blue-500"
                onClick={() => onEdit(product)}
              >
                Edit
              </button>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};

export default ProductTable;

// src/components/Products/AddEditProductModal.tsx
import React, { useState } from "react";

const AddEditProductModal = ({ isOpen, onClose, product }: any) => {
  const [name, setName] = useState(product?.name || "");
  const [category, setCategory] = useState(product?.category || "");
  const [price, setPrice] = useState(product?.price || "");

  const handleSubmit = () => {
    // Handle product save logic here
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white p-6 rounded">
        <h2 className="text-xl mb-4">{product ? "Edit Product" : "Add Product"}</h2>
        <form
          onSubmit={(e) => {
            e.preventDefault();
            handleSubmit();
          }}
        >
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Name</label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full border rounded px-2 py-1"
            />
          </div>
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Category</label>
            <input
              type="text"
              value={category}
              onChange={(e) => setCategory(e.target.value)}
              className="w-full border rounded px-2 py-1"
            />
          </div>
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Price</label>
            <input
              type="number"
              value={price}
              onChange={(e) => setPrice(e.target.value)}
              className="w-full border rounded px-2 py-1"
            />
          </div>
          <div className="flex justify-end">
            <button
              type="button"
              onClick={onClose}
              className="mr-2 bg-gray-300 px-4 py-2 rounded"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-primary text-white px-4 py-2 rounded"
            >
              Save
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default AddEditProductModal;

// Step 7: Product Management API
// src/pages/api/products/index.ts
import { NextApiRequest, NextApiResponse } from "next";
import prisma from "@/lib/prisma";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    if (req.method === "GET") {
      const products = await prisma.product.findMany();
      res.status(200).json(products);
    } else if (req.method === "POST") {
      const { name, category, price } = req.body;
      const product = await prisma.product.create({
        data: { name, category, price },
      });
      res.status(201).json(product);
    } else {
      res.setHeader("Allow", ["GET", "POST"]);
      res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Failed to manage products" });
  }
}

// Step 8: Customer Management Components
// src/components/Customers/CustomersPanel.tsx
import React, { useState } from "react";
import useSWR from "swr";
import fetcher from "@/utils/api";
import CustomerTable from "@/components/Customers/CustomerTable";
import ViewCustomerModal from "@/components/Customers/ViewCustomerModal";

const CustomersPanel: React.FC = () => {
  const { data: customers, error } = useSWR("/api/customers", fetcher);
  const [selectedCustomer, setSelectedCustomer] = useState(null);

  const handleViewCustomer = (customer: any) => {
    setSelectedCustomer(customer);
  };

  const handleCloseModal = () => {
    setSelectedCustomer(null);
  };

  if (error) return <div>Error loading customers.</div>;
  if (!customers) return <div>Loading...</div>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Customers</h1>
      </div>
      <CustomerTable customers={customers} onView={handleViewCustomer} />
      <ViewCustomerModal
        customer={selectedCustomer}
        isOpen={!!selectedCustomer}
        onClose={handleCloseModal}
      />
    </div>
  );
};

export default CustomersPanel;

// src/components/Customers/CustomerTable.tsx
import React from "react";

const CustomerTable = ({ customers, onView }: { customers: any[]; onView: (customer: any) => void }) => {
  return (
    <table className="min-w-full bg-white">
      <thead>
        <tr>
          <th className="px-4 py-2">Name</th>
          <th className="px-4 py-2">Email</th>
          <th className="px-4 py-2">Actions</th>
        </tr>
      </thead>
      <tbody>
        {customers.map((customer) => (
          <tr key={customer.customer_id}>
            <td className="border px-4 py-2">{customer.name}</td>
            <td className="border px-4 py-2">{customer.email}</td>
            <td className="border px-4 py-2">
              <button
                className="text-blue-500"
                onClick={() => onView(customer)}
              >
                View
              </button>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};

export default CustomerTable;

// src/components/Customers/ViewCustomerModal.tsx
import React from "react";

const ViewCustomerModal = ({ customer, isOpen, onClose }: any) => {
  if (!isOpen || !customer) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white p-6 rounded">
        <h2 className="text-xl mb-4">Customer Details</h2>
        <p><strong>Name:</strong> {customer.name}</p>
        <p><strong>Email:</strong> {customer.email}</p>
        <p><strong>Phone:</strong> {customer.phone || "N

